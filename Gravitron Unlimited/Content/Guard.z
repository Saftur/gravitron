class Guard : ZilchComponent
{
    [Dependency]
    var Socks : Physocks = null;
    
    // Pacing Properties and variables
    [Property]
    var Active : Boolean = true;
    [Property]
    var LeftPoint : Real3 = Real3(0,0,0);
    [Property]
    var MaxMoveDistance: Real = 10.0;
    var PaceDirection: Real3 = Real3(1.0, 0.0, 0.0);
    var StartPosition: Real3 = Real3();


     // Chasing Properties and variables
    [Property]
    var TargetObject: CogPath = null;
    [Property]
    var VisionRange : Real = 5;
    
    var Dir : Real3 = Real3();
    
    var Player : Cog = null;
    
    [Property]
    var Type : Integer = 1; //Differentiate types of guards here
    
    function Initialize(init : CogInitializer)
    {
        Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
        this.Player = this.Space.FindObjectByName("Player");
    }

    function OnLogicUpdate(event : UpdateEvent)
    {
        if(!this.Active) return;
        var ray = Ray();
        var pos = this.Owner.Transform.Translation;
        var h = this.Owner.Transform.Scale.Y;
        
        ray.Start = pos;
        ray.Direction = this.Dir;
        
        if(this.Look())
        {
            this.Chase();
        }
        else
        {
            this.Patrol();
        }
        //Console.WriteLine("`this.CastRay(ray, 2, null)`");
        //Jumping
        if(this.Socks.Grounded())
        {
            if(this.CastRay(ray, 0.3, null)) this.Socks.Jump(); //middle
            
            //ray.Start = pos + Real3(0, h/2, 0);
            //if(this.CastRay(ray, 0.3, null)) this.Socks.Jump(); //top
            
            ray.Start = pos + Real3(0, -h/2, 0);
            if(this.CastRay(ray, 0.3, null)) this.Socks.Jump(); //bottom
        }
    }
    function Chase()
    {
    }
    function Patrol()
    {
        //Patrolling
        var displacement = this.Owner.Transform.Translation - this.StartPosition;
         
        var distanceFromStart = Math.Length(displacement);

        // If we have travelled past our max distance
        if (distanceFromStart >= this.MaxMoveDistance)
        {
            this.Owner.Sprite.FlipX = true;
            this.Dir = Real3(-1,0,0);
        }

        // Ensure the PaceDirection is only a direction via normlization
        this.PaceDirection = Math.Normalize(this.PaceDirection);

        // Apply movement
                        // Reevaluate the situation to determine if our object should pursue

        // If our target exists
        if (this.TargetObject.Cog != null)
        {
            this.Dir = Real3(1,0,0);
            this.Owner.Sprite.FlipX = false;
        }
        this.Socks.Update(this.Dir);
    }
    function Look() : Boolean
    {
        debug return false;
        var ray = Ray();
        var pos = this.Owner.Transform.Translation;
        var h = this.Owner.Transform.Scale.Y;
        
        ray.Start = pos;
        ray.Direction = this.Dir;
        
        ray.Start = pos;
        if(this.CastRay(ray, this.VisionRange, this.Player)) return true;
            
        ray.Start = pos + Real3(0, h/2, 0);
        if(this.CastRay(ray, this.VisionRange, this.Player)) return true; //top
        
        ray.Start = pos + Real3(0, -h +0.1, 0);
        if(this.CastRay(ray, this.VisionRange, this.Player)) return true; //bottom
        
        return false;
    }
    function CastRay(ray : Ray, dis : Real, cog : Cog) : Boolean
    {
        var objHit = this.Space.PhysicsSpace.CastRayFirst(ray);
        if(objHit != null && objHit.Distance <= dis)
        {
            if(cog != null && objHit.ObjectHit == cog)
            {
                return true;
            }
            else
            {
                Console.WriteLine("`objHit.ObjectHit` `objHit.Distance`");
                return true;
            }
        }
        return false;
    }
    
}